<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> mapbuilder by sadghostx </title>
    <link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --main-font: 'Libre Baskerville', Georgia, serif;
            --main-blue: #007bff;
            --main-purple: #6f42c1; 
            --button-bg: #e9ecef;
            --button-border: #343a40;
            --button-text: #343a40;
            --button-hover: #dee2e6;
            --button-active: #d6d6d6;
            --control-bg: #ffffff;
            --border-color: #e9ecef;
            --light-grey: #f0f0f0;
            --dark-grey-text: #343a40;
            --min-tap-size: 44px;
            --toolbar-height: 60px; /* Define a fixed height for the toolbar */
        }

        body {
            font-family: var(--main-font);
            display: flex;
            gap: 20px;
            padding: 20px;
            background-color: var(--light-grey);
            min-height: 100vh;
            margin: 0;
            flex-direction: row; 
        }

        #controls {
            flex-shrink: 0;
            width: 300px;
            background: var(--control-bg);
            padding: 0;
            border-radius: 10px;
            box-shadow: 0 0 0 1px var(--border-color), 0 8px 16px rgba(0,0,0,0.1); 
            display: flex;
            flex-direction: column;
            gap: 0;
            position: relative;
            overflow: visible;
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
        }

        .control-group {
            background-color: var(--control-bg);
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 0;
        }
        
        /* ... (Control group styling remains the same) ... */

        #image-container {
            flex-grow: 1;
            background: var(--control-bg);
            border-radius: 10px;
            padding: 0; /* Removed padding to make toolbar flush */
            text-align: center;
            overflow: hidden;
            position: relative;
            box-shadow: 0 0 0 1px var(--border-color), 0 8px 16px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column; 
        }

        /* --- FIXED TOOLBAR STYLING --- */
        #toolbar-container {
            /* FIXED POSITIONING */
            position: sticky; 
            top: 0;
            z-index: 50; /* Ensure it stays above canvas wrapper content */
            
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            height: var(--toolbar-height);
            padding: 0 10px; /* Add padding here instead of image-container */
            box-sizing: border-box;
            background-color: var(--control-bg); /* Opaque background */
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap; 
        }

        #canvas-wrapper {
            transition: transform 0.1s ease-out;
            transform-origin: 0 0;
            cursor: grab;
            display: block; /* Change to block for full width scrolling */
            flex-grow: 1;
            overflow: auto; /* Enable scrolling for the canvas wrapper content */
            touch-action: none;
            padding: 10px; /* Add canvas padding back here */
        }
        
        canvas {
            border: 1px solid #ccc;
            display: block;
            margin: 0 auto;
        }
        
        /* --- Label Box Styles --- */
        .label-box {
            display: flex;
            align-items: center;
            padding: 8px 10px; 
            border: 1px solid var(--border-color);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            background-color: #f8f9fa;
            min-height: 36px;
        }

        .label-box-actions {
            margin-left: 10px;
            flex-shrink: 0;
            display: flex;
            gap: 5px; /* Added gap for multiple buttons */
        }

        .label-box-actions button {
            min-width: 36px; /* Smaller tap area for edit/delete buttons */
            min-height: 36px;
            background: none;
            border: none;
            color: var(--dark-grey-text);
            font-size: 1em;
            cursor: pointer;
            padding: 0;
            line-height: 1; 
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        .label-box-actions button.delete-btn {
            color: #dc3545;
        }

        /* --- Color Picker Popup Styles --- */
        #color-swatch-popup {
            /* Position relative to controls container */
            position: absolute;
            top: 250px; /* Adjusted position due to potentially more content */
            left: 15px; 
            width: calc(100% - 30px);
            max-width: 270px;
            background: var(--control-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            padding: 10px;
            z-index: 100;
            display: none;
            flex-direction: column;
        }
        
        /* --- MEDIA QUERY: STACKED MOBILE LAYOUT --- */
        @media (max-width: 900px) {
            body {
                flex-direction: column; 
                padding: 10px;
                gap: 10px;
            }

            #controls-toggle {
                display: block;
            }

            #controls {
                width: 100%;
                box-sizing: border-box;
                order: 1;
                transform: translateY(-100%); 
                opacity: 0;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                height: 100vh;
                max-height: 100vh;
                z-index: 100;
                overflow-y: auto;
                border-radius: 0;
                box-shadow: none;
            }
            
            #controls.show {
                transform: translateY(0);
                opacity: 1;
            }
            
            #image-container {
                order: 2;
                flex-grow: 1;
                min-height: calc(100vh - 20px);
                padding-top: var(--toolbar-height); /* Make space for fixed toolbar */
            }
            
            #toolbar-container {
                position: fixed; /* Fix the toolbar to the viewport top */
                top: 0;
                left: 0;
                right: 0;
                border-radius: 0;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                width: 100%;
                /* Override mobile padding */
                padding-left: 10px;
                padding-right: 10px;
            }

            #canvas-wrapper {
                 /* Adjust canvas wrapper padding for fixed toolbar */
                 padding-top: 0;
            }
        }
    </style>
</head>
<body>

    <button id="controls-toggle">üõ†Ô∏è</button>

    <div id="controls">
        <div class="control-group" id="mobile-close-group" style="display: none; justify-content: flex-end;">
            <button class="action-button" onclick="document.getElementById('controls').classList.remove('show');" style="width: auto; padding: 5px 15px;">Close Controls ‚ùå</button>
        </div>

        <div class="control-group">
            <h2>1. Image Load</h2>
            <input type="file" id="imageLoader" accept="image/*">
        </div>

        <div class="control-group">
            <h2>2. Define Label</h2>
            <div class="input-group">
                <input type="text" id="newLabelName" placeholder="Label Name" required>
            </div>
            
            <button id="selectedColorButton">
                <div id="selectedColorPreview"></div>
                <span>Select Color</span>
            </button>
            
            <button id="addLabelBtn" class="action-button" onclick="addLabel()">Add Label</button>
        </div>
        
        <div id="color-swatch-popup">
            <div class="popup-header">Choose a Label Color:</div>
            <div id="color-swatch-selector"></div>
        </div>

        <div class="control-group">
            <h2>3. Label List</h2>
            <div id="labels-container"></div>
            <p style="font-size: 0.8em; margin-top: 10px; font-family: var(--main-font);">
                Click a label to select/deselect it for coloring. Use the dropper to edit color.
            </p>
        </div>
        
        <div class="control-group">
            <h2>4. Tools</h2>
            <div class="action-button utility-button-group" style="margin-bottom: 10px;">
                <button id="fillEraserBtn">üßπ Fill Eraser</button> 
                <button id="dragEraserBtn">üñåÔ∏è Drag Eraser</button> 
            </div>
            <div class="action-button utility-button-group">
                <button id="undoBtn" disabled>‚Ü©Ô∏è Undo</button>
                <button id="clearAllBtn" disabled>üóëÔ∏è Clear All</button>
            </div>
        </div>

        <div class="control-group">
            <h2>5. Save</h2>
            <button id="downloadBtn" class="action-button">Download Labeled Image</button>
        </div>
    </div>

    <div id="image-container">
        <div id="toolbar-container">
            <div id="zoom-controls">
                <span class="control-label">Zoom:</span>
                <button id="zoomInBtn" class="action-button">+</button>
                <button id="zoomOutBtn" class="action-button">-</button>
                <span id="currentZoomLevel">100%</span>
                <button id="zoomResetBtn" class="action-button">Reset</button>
            </div>

            <div id="label-scale-controls">
                <span class="control-label">Label Size:</span>
                <input type="range" id="labelScaleSlider" min="10" max="100" value="16"> 
                <button id="labelScaleResetBtn" class="action-button">Reset</button>
            </div>
        </div>
        
        <div id="canvas-wrapper">
            <canvas id="imageCanvas"></canvas>
        </div>
    </div>

    <script>
        // --- MOBILE UI ELEMENTS ---
        const controlsToggle = document.getElementById('controls-toggle');
        const controls = document.getElementById('controls');
        const mobileCloseGroup = document.getElementById('mobile-close-group');
        
        controlsToggle.addEventListener('click', () => {
            controls.classList.toggle('show');
        });

        function updateMobileUI() {
            const isMobile = window.matchMedia("(max-width: 900px)").matches;
            mobileCloseGroup.style.display = isMobile ? 'flex' : 'none';
        }
        window.addEventListener('resize', updateMobileUI);
        document.addEventListener('DOMContentLoaded', updateMobileUI);
        
        // --- END MOBILE UI ELEMENTS ---
        
        
        // --- EXISTING CODE VARIABLES ---
        const canvas = document.getElementById('imageCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const imageLoader = document.getElementById('imageLoader');
        const labelsContainer = document.getElementById('labels-container');
        const downloadBtn = document.getElementById('downloadBtn');
        const newLabelNameInput = document.getElementById('newLabelName');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const undoBtn = document.getElementById('undoBtn');
        const clearAllBtn = document.getElementById('clearAllBtn');
        const fillEraserBtn = document.getElementById('fillEraserBtn'); 
        const dragEraserBtn = document.getElementById('dragEraserBtn'); 
        const selectedColorButton = document.getElementById('selectedColorButton'); 
        const selectedColorPreview = document.getElementById('selectedColorPreview'); 
        const colorSwatchPopup = document.getElementById('color-swatch-popup'); 
        const colorSwatchSelector = document.getElementById('color-swatch-selector'); 
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomResetBtn = document.getElementById('zoomResetBtn');
        const currentZoomLevelEl = document.getElementById('currentZoomLevel');
        const labelScaleSlider = document.getElementById('labelScaleSlider'); 
        const labelScaleResetBtn = document.getElementById('labelScaleResetBtn'); 

        let currentImage = null;
        let labels = [];
        let activeLabel = null;
        // Modified: selectedColor is now the color being defined, not the active label color
        let selectedColor = null; 
        
        const FILL_OPACITY = 0.6;
        const COLOR_TOLERANCE = 35; 
        const GAP_TOLERANCE = 10;
        const DEFAULT_LABEL_FONT_SIZE = 16; 
        let currentLabelFontSize = DEFAULT_LABEL_FONT_SIZE; 
        const LABEL_FONT_FAMILY = "'Libre Baskerville', Arial"; 
        
        let zoomLevel = 1.0;
        const MAX_ZOOM = 4.0;
        const MIN_ZOOM = 0.5;
        let isDragging = false;
        let pan = { x: 0, y: 0, startX: 0, startY: 0 };
        
        let history = [];
        const MAX_HISTORY_SIZE = 20;

        const PRESET_COLORS = [
            "#ff4040", "#40ff40", "#4040ff", 
            "#ffaa40", "#40ffff", "#ff40ff", 
            "#ffaa00", "#aa40ff", "#40aa00", 
            "#00aaff"  
        ];

        let activeEraser = 0; 
        let isErasingDragging = false;
        const ERASER_SIZE = 30;

        let originalImageData = null; 
        let initialPinchDistance = null;
        let initialZoom = 1.0;
        let isPanningTouch = false;
        
        // --- UTILITY FUNCTIONS (Kept as is) ---
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.substring(1, 3), 16);
            const g = parseInt(hex.substring(3, 5), 16);
            const b = parseInt(hex.substring(5, 7), 16);
            const a = Math.round(alpha * 255);
            return [r, g, b, a];
        }

        function getPixelColor(data, x, y, width) {
            const index = (y * width + x) * 4;
            if (index < 0 || index >= data.length) return [0, 0, 0, 0];
            return [data[index], data[index + 1], data[index + 2], data[index + 3]];
        }

        function setPixelColor(data, x, y, width, color) {
            const index = (y * width + x) * 4;
            data[index] = color[0];
            data[index + 1] = color[1];
            data[index + 2] = color[2];
            data[index + 3] = color[3];
        }

        function colorDifference(color1, color2) {
            return Math.sqrt(
                Math.pow(color1[0] - color2[0], 2) +
                Math.pow(color1[1] - color2[1], 2) +
                Math.pow(color1[2] - color2[2], 2)
            );
        }
        
        // --- HISTORY TRACKING (Kept as is) ---
        function saveState() {
            if (!currentImage) return;

            if (history.length >= MAX_HISTORY_SIZE) {
                history.shift();
            }
            
            history.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
            
            updateUtilityButtonState();
        }

        function restoreState(imageData) {
            if (!currentImage) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.putImageData(imageData, 0, 0);
        }
        
        function updateUtilityButtonState() {
            const hasHistory = history.length > 1;
            undoBtn.disabled = !hasHistory;
            clearAllBtn.disabled = history.length === 0;
            
            fillEraserBtn.disabled = !currentImage; 
            dragEraserBtn.disabled = !currentImage;

            fillEraserBtn.classList.toggle('active', activeEraser === 1);
            dragEraserBtn.classList.toggle('active', activeEraser === 2);

            if (!currentImage) {
                activeEraser = 0;
                canvas.classList.remove('eraser-cursor');
            }
        }
        
        // --- Color Picker Popup Logic ---
        selectedColorButton.addEventListener('click', () => {
             // If active label exists, open color picker to edit its color
            if (activeLabel) {
                 selectColor(activeLabel.color); // Pre-select current color
            } else {
                 highlightRecommendedColor(); // Suggest a new color
            }
            colorSwatchPopup.style.display = 'flex';
        });

        document.addEventListener('click', (event) => {
            const isClickInsideControls = document.getElementById('controls').contains(event.target);
            const isClickInsidePopup = colorSwatchPopup.contains(event.target);
            const isColorButton = selectedColorButton.contains(event.target);
            
            if (colorSwatchPopup.style.display === 'flex' && !isClickInsidePopup && !isColorButton) {
                if (isClickInsideControls) { 
                     colorSwatchPopup.style.display = 'none';
                     
                     // If we were editing, restore the active label color as selected color
                     if(activeLabel) {
                         selectColor(activeLabel.color);
                     } else {
                         // Otherwise, re-run recommendation
                         highlightRecommendedColor();
                     }
                }
            }
        });

        // Modified: Now handles both new color selection and active label color update
        function selectColor(color) {
            selectedColor = color; 
            selectedColorPreview.style.backgroundColor = color;
            
            const swatches = colorSwatchSelector.querySelectorAll('.color-swatch');
            swatches.forEach(swatch => {
                swatch.classList.remove('active', 'recommended');
                if (swatch.dataset.color === color) {
                    swatch.classList.add('active');
                }
            });

            // If an active label exists, update its color immediately
            if (activeLabel) {
                activeLabel.color = color;
                renderLabels();
            }
            
            highlightRecommendedColor();
            colorSwatchPopup.style.display = 'none'; 
        }

        // Modified: ensures the next recommended color is unique
        function highlightRecommendedColor() {
            const usedColors = new Set(labels.map(l => l.color));
            
            // If editing an existing label, don't count its own color as 'used'
            if (activeLabel) {
                usedColors.delete(activeLabel.color);
            }
            
            let nextColor = PRESET_COLORS.find(color => !usedColors.has(color));
            if (!nextColor) {
                 nextColor = PRESET_COLORS[0]; // If all used, default to first color
            }

            const swatches = colorSwatchSelector.querySelectorAll('.color-swatch');
            swatches.forEach(swatch => {
                if (swatch.dataset.color === nextColor && swatch.dataset.color !== selectedColor) {
                    swatch.classList.add('recommended');
                } else {
                    swatch.classList.remove('recommended');
                }
            });

            // Auto-select a color if none is selected, or if we are defining a new label
            if (activeLabel === null) {
                 selectedColor = nextColor; 
                 selectedColorPreview.style.backgroundColor = nextColor;
            }
        }

        function populateColorSwatches() {
            colorSwatchSelector.innerHTML = '';
            PRESET_COLORS.forEach(color => {
                const swatch = document.createElement('div');
                swatch.classList.add('color-swatch');
                swatch.style.backgroundColor = color;
                swatch.dataset.color = color;
                swatch.title = color;
                swatch.onclick = () => selectColor(color);
                colorSwatchSelector.appendChild(swatch);
            });
            
            // Set initial selected color to the recommended one
            highlightRecommendedColor();
        }

        // --- RENDER & LABEL MANAGEMENT ---

        function setActiveLabel(label) {
            if (activeLabel && activeLabel.id === label.id) {
                activeLabel = null;
            } else {
                activeLabel = label;
                activeEraser = 0; 
                canvas.classList.remove('eraser-cursor'); 
                isErasingDragging = false;
            }
            renderLabels();
            updateUtilityButtonState();
        }

        function renderLabels() {
            labelsContainer.innerHTML = '';
            labels.forEach(label => {
                const div = document.createElement('div');
                div.classList.add('label-box');
                if (activeLabel && activeLabel.id === label.id) {
                    div.classList.add('active');
                }
                div.onclick = () => setActiveLabel(label);

                const preview = document.createElement('div');
                preview.classList.add('label-color-preview');
                preview.style.backgroundColor = label.color;

                const text = document.createElement('span');
                text.classList.add('label-box-text');
                text.textContent = label.name;

                const actions = document.createElement('div');
                actions.classList.add('label-box-actions');
                
                // Color Edit Button (Dropper)
                const editColorBtn = document.createElement('button');
                editColorBtn.textContent = 'üé®';
                editColorBtn.title = 'Edit Color';
                editColorBtn.onclick = (e) => {
                    e.stopPropagation();
                    setActiveLabel(label); // Make it active first
                    selectColor(label.color); // Set the selected color to the label's color
                    colorSwatchPopup.style.display = 'flex'; // Open popup
                };


                const deleteBtn = document.createElement('button');
                deleteBtn.classList.add('delete-btn');
                deleteBtn.textContent = '‚úï';
                deleteBtn.title = 'Delete Label';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    labels = labels.filter(l => l.id !== label.id);
                    if (activeLabel && activeLabel.id === label.id) activeLabel = null;
                    renderLabels();
                    highlightRecommendedColor(); 
                };

                actions.appendChild(editColorBtn); 
                actions.appendChild(deleteBtn);

                div.appendChild(preview);
                div.appendChild(text);
                div.appendChild(actions); 

                labelsContainer.appendChild(div);
            });
        }

        // --- 1. IMAGE LOADING (Kept as is) ---
        imageLoader.addEventListener('change', handleImage, false);

        function handleImage(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                currentImage = new Image();
                currentImage.onload = () => {
                    canvas.width = currentImage.width;
                    canvas.height = currentImage.height;

                    setZoomLevel(1.0);
                    pan = { x: 0, y: 0, startX: 0, startY: 0 };
                    applyZoomAndPan();

                    ctx.drawImage(currentImage, 0, 0);
                    
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(currentImage, 0, 0);
                    originalImageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);


                    history = []; 
                    saveState(); 
                    updateUtilityButtonState();
                    
                    populateColorSwatches();
                };
                currentImage.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        // --- 2. LABEL DEFINITION ---
        function addLabel() {
            const name = newLabelNameInput.value.trim();
            const color = selectedColor;

            if (!name) {
                alert("Please enter a label name.");
                return;
            }
            if (!color) {
                alert("Internal error: No recommended color found.");
                return;
            }

            if (labels.some(label => label.name === name)) {
                 alert("A label with this name already exists.");
                 return;
            }
            
            // Check for color duplication only for *new* labels
            if (labels.some(label => label.color === color)) {
                 // Should be rare due to highlightRecommendedColor logic, but keep check.
                 if (!confirm(`Color ${color} is already used. Do you want to use it again?`)) {
                    return;
                 }
            }

            const newLabel = { name, color, id: Date.now() };
            labels.push(newLabel);

            newLabelNameInput.value = '';

            setActiveLabel(newLabel);
            highlightRecommendedColor(); // Get next unique color ready for the next label
        }

        // --- 3. COLOR FILLING (Click/Flood Fill) ---

        canvas.addEventListener('click', handleCanvasClick, { passive: true });
        // ... (Eraser button event listeners remain the same) ...

        function getCanvasPoint(event) {
            const rect = canvas.getBoundingClientRect();
            
            // Account for zoom and pan on the wrapper
            const wrapperRect = canvasWrapper.getBoundingClientRect();
            const clientX = event.clientX;
            const clientY = event.clientY;
            
            // Calculate coordinates relative to the zoomed and panned canvas
            let x = (clientX - wrapperRect.left) / zoomLevel;
            let y = (clientY - wrapperRect.top) / zoomLevel;
            
            // Adjust for canvas's actual position within the wrapper when zoomed in
            x -= pan.x / zoomLevel;
            y -= pan.y / zoomLevel;

            // Scale to canvas's intrinsic resolution
            const scaleX = canvas.width / rect.width; 
            const scaleY = canvas.height / rect.height;
            
            x *= scaleX;
            y *= scaleY;
            
            return { x: Math.floor(x), y: Math.floor(y) };
        }
        
        function getCanvasPointFromTouch(touch) {
            const rect = canvas.getBoundingClientRect();
            
            const wrapperRect = canvasWrapper.getBoundingClientRect();
            
            let x = (touch.clientX - wrapperRect.left) / zoomLevel;
            let y = (touch.clientY - wrapperRect.top) / zoomLevel;

            x -= pan.x / zoomLevel;
            y -= pan.y / zoomLevel;
            
            const scaleX = canvas.width / rect.width; 
            const scaleY = canvas.height / rect.height;
            
            x *= scaleX;
            y *= scaleY;
            
            return { x: Math.floor(x), y: Math.floor(y) };
        }

        function handleCanvasClick(event) {
            if (!currentImage) {
                alert("Please load an image first.");
                return;
            }
            
            if (isPanningTouch || initialPinchDistance !== null || isDragging) return;
            
            // Ignore synthetic click events from touch/pointer if a drag occurred
            if (event.pointerType && (event.pointerType === 'touch' || event.pointerType === 'pen') && event.detail === 0) return;
            
            // Use clientX/Y from the event for mouse clicks
            const { x, y } = getCanvasPoint(event);
            
            if (activeEraser === 0 && !activeLabel) {
                 alert("Please select an active label or an eraser tool.");
                 return;
            }

            if (activeEraser === 2) return; 
            
            if (activeEraser === 1) { 
                saveState();
                handleFillEraserClick(x, y);
                saveState();
            } else if (activeLabel) { 
                saveState();
                handleFillClick(x, y);
                saveState();
            }
        }
        
        function handleFillClick(x, y) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(canvas, 0, 0); 

            const imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // CRITICAL FIX: The target color must be the color of the pixel on the original image, 
            // since we are flooding an uncolored area (transparent/original image pixel).
            const originalData = originalImageData.data;
            const initialPixelColor = getPixelColor(originalData, x, y, canvas.width);


            const fillColor = hexToRgba(activeLabel.color, FILL_OPACITY);

            // Pass originalImageData so flood fill can use it for color checks
            const filledPixelsCount = floodFill(data, x, y, canvas.width, canvas.height, initialPixelColor, fillColor, false, originalImageData.data); 

            tempCtx.putImageData(imageData, 0, 0); 

            if (filledPixelsCount > 0) {
                tempCtx.font = `bold ${currentLabelFontSize}px ${LABEL_FONT_FAMILY}`; 
                tempCtx.fillStyle = '#000000'; 
                tempCtx.textAlign = 'center';
                tempCtx.textBaseline = 'middle';
                tempCtx.fillText(activeLabel.name, x, y); 

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(tempCanvas, 0, 0);
            }
        }
        
        function handleFillEraserClick(x, y) {
            if (!originalImageData) return;

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(canvas, 0, 0);
            const currentImageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
            const data = currentImageData.data;

            const initialPixelColor = getPixelColor(data, x, y, canvas.width);
            
            if (initialPixelColor[3] < 100) return; 
            
            // Pass original data for the erase operation
            const clearedPixelsCount = floodFill(data, x, y, canvas.width, canvas.height, initialPixelColor, null, true, originalImageData.data); 

            if (clearedPixelsCount > 0) {
                tempCtx.putImageData(currentImageData, 0, 0); 
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(tempCanvas, 0, 0);
            }
        }

        // --- Drag Eraser Logic (Adjusted to use new coordinate function) ---
        canvas.addEventListener('mousedown', (e) => {
            if (activeEraser === 2) { 
                e.preventDefault(); 
                isErasingDragging = true;
                saveState(); 
                handleDragEraserMove(e); 
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (activeEraser === 2 && isErasingDragging) {
                handleDragEraserMove(e);
            }
        });

        document.addEventListener('mouseup', () => {
            if (isErasingDragging) {
                isErasingDragging = false;
                saveState(); 
            }
        });
        
        // Touch events for drag eraser (Kept as is, using touchmove preventDefault)
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1 && activeEraser === 2) {
                 isErasingDragging = true;
                 saveState();
                 handleDragEraserMoveTouch(e.touches[0]);
            }
        }, { passive: true });
        
        canvas.addEventListener('touchmove', (e) => {
            if (isErasingDragging) {
                e.preventDefault(); 
                handleDragEraserMoveTouch(e.touches[0]);
            }
        }, { passive: false });
        
        canvas.addEventListener('touchend', () => {
             if (isErasingDragging) {
                isErasingDragging = false;
                saveState();
             }
        });

        function handleDragEraserMove(event) {
            if (!currentImage || !originalImageData) return;

            const { x, y } = getCanvasPoint(event); // Use updated getCanvasPoint

            const currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = currentImageData.data;

            const halfSize = ERASER_SIZE / 2;
            const startX = Math.max(0, x - halfSize);
            const startY = Math.max(0, y - halfSize);
            const endX = Math.min(canvas.width, x + halfSize);
            const endY = Math.min(canvas.height, y + halfSize);

            for (let i = startX; i < endX; i++) {
                for (let j = startY; j < endY; j++) {
                    const dist = Math.sqrt(Math.pow(i - x, 2) + Math.pow(j - y, 2));
                    if (dist <= halfSize) {
                        const originalColor = getPixelColor(originalImageData.data, i, j, canvas.width);
                        setPixelColor(data, i, j, canvas.width, originalColor);
                    }
                }
            }
            ctx.putImageData(currentImageData, 0, 0);
        }
        
        function handleDragEraserMoveTouch(touch) {
            if (!currentImage || !originalImageData) return;

            const { x, y } = getCanvasPointFromTouch(touch);

            const currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = currentImageData.data;

            const halfSize = ERASER_SIZE / 2;
            const startX = Math.max(0, x - halfSize);
            const startY = Math.max(0, y - halfSize);
            const endX = Math.min(canvas.width, x + halfSize);
            const endY = Math.min(canvas.height, y + halfSize);

            for (let i = startX; i < endX; i++) {
                for (let j = startY; j < endY; j++) {
                    const dist = Math.sqrt(Math.pow(i - x, 2) + Math.pow(j - y, 2));
                    if (dist <= halfSize) {
                        const originalColor = getPixelColor(originalImageData.data, i, j, canvas.width);
                        setPixelColor(data, i, j, canvas.width, originalColor);
                    }
                }
            }
            ctx.putImageData(currentImageData, 0, 0);
        }

        // --- FLOOD FILL ALGORITHM (Modified) ---
        function floodFill(data, x, y, width, height, targetColor, fillColor, isErase, sourceData) {
            if (x < 0 || x >= width || y < 0 || y >= height) return 0;
            
            const queue = [[x, y]];
            const visited = new Uint8Array(width * height);
            let filledCount = 0;
            
            while (queue.length > 0) {
                const [cx, cy] = queue.shift();

                const pixelIndex = cy * width + cx;
                if (visited[pixelIndex]) continue;

                visited[pixelIndex] = 1;

                const currentColor = getPixelColor(data, cx, cy, width);
                let shouldFill = false;
                let nextFillColor = fillColor;

                if (isErase) {
                    // For Erase: Check if the current pixel is *not* the original image pixel 
                    const originalPixelColor = getPixelColor(sourceData, cx, cy, width);
                    if (colorDifference(currentColor, originalPixelColor) > 50 || currentColor[3] < 250) { 
                        shouldFill = true;
                        nextFillColor = originalPixelColor; // Restore original color
                    }
                } else {
                    // For Fill: Check if the pixel matches the *initial* target color from the ORIGINAL image layer
                    const originalPixelColor = getPixelColor(sourceData, cx, cy, width);
                    const diffFromTarget = colorDifference(originalPixelColor, targetColor);
                    
                    // Crucial Fix: Only fill if the current pixel is NOT already colored (alpha check) AND its original color is close to the starting point's original color.
                    if (currentColor[3] < 100) { // Check if the area is uncolored (mostly transparent)
                        if (diffFromTarget < COLOR_TOLERANCE) {
                            shouldFill = true;
                        }
                    } else {
                         continue; // Don't continue the flood into areas already colored
                    }
                }

                if (shouldFill) {
                    setPixelColor(data, cx, cy, width, nextFillColor);
                    filledCount++;
                    
                    const neighbors = [[cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]];

                    neighbors.forEach(([nx, ny]) => {
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            const nIndex = ny * width + nx;
                            if (!visited[nIndex]) {
                                queue.push([nx, ny]);
                            }
                        }
                    });
                }
            }
            return filledCount;
        }


        // --- UNDO/CLEAR ADDITIONS (Kept as is) ---
        undoBtn.addEventListener('click', () => {
            if (history.length > 1) {
                history.pop(); 
                const previousState = history[history.length - 1]; 
                restoreState(previousState);
                updateUtilityButtonState();
            } else if (history.length === 1) {
                clearAll();
            }
        });
        
        clearAllBtn.addEventListener('click', clearAll);

        function clearAll() {
            if (!currentImage) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(currentImage, 0, 0);
            
            history = [];
            saveState(); 
            updateUtilityButtonState();
        }

        // --- ZOOM AND PAN CONTROLS (Updated coordinate systems) ---
        function setZoomLevel(newLevel) {
            zoomLevel = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newLevel)); 
            currentZoomLevelEl.textContent = `${Math.round(zoomLevel * 100)}%`;
            applyZoomAndPan();
        }

        function applyZoomAndPan() {
            // Apply zoom to the canvas element itself (not the wrapper)
            canvas.style.transform = `scale(${zoomLevel})`; 
            // Apply pan to the canvas's position relative to its wrapper
            canvas.style.marginLeft = `${pan.x}px`;
            canvas.style.marginTop = `${pan.y}px`;
            
            // To maintain centering when not zoomed/panned, ensure canvas is centered initially.
            // When zoomed, the canvas wrapper scrolling takes over for large images.
            // NOTE: The previous version used wrapper scale/translate. Reverting to canvas scale and pan through margins/positioning is often easier when the wrapper has `overflow: auto`.
            
            // Re-applying original style for simplicity, but making sure the coordinates (getCanvasPoint) are correct:
            canvasWrapper.style.transform = `translate(${pan.x}px, ${pan.y}px) scale(${zoomLevel})`; 
        }
        
        // ... (Zoom button handlers and mouse listeners remain the same) ...

        // --- TOUCH/PINCH GESTURE HANDLING (Kept as is) ---

        function getDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        canvasWrapper.addEventListener('touchstart', (e) => {
            if (activeEraser === 2) return; 
            
            if (e.touches.length === 2) {
                initialPinchDistance = getDistance(e.touches);
                initialZoom = zoomLevel;
                isPanningTouch = false;
            } else if (e.touches.length === 1) {
                isPanningTouch = true;
                pan.startX = e.touches[0].clientX - pan.x;
                pan.startY = e.touches[0].clientY - pan.y;
            }
        }, { passive: true });

        canvasWrapper.addEventListener('touchmove', (e) => {
            if (activeEraser === 2) return;
            
            if (e.touches.length === 2) {
                e.preventDefault(); 
                const currentDistance = getDistance(e.touches);
                const scale = currentDistance / initialPinchDistance;
                setZoomLevel(initialZoom * scale);
                isPanningTouch = false;
            } else if (e.touches.length === 1 && isPanningTouch) {
                e.preventDefault(); 
                pan.x = e.touches[0].clientX - pan.startX;
                pan.y = e.touches[0].clientY - pan.startY;
                applyZoomAndPan();
            }
        }, { passive: false }); 

        canvasWrapper.addEventListener('touchend', (e) => {
            if (e.touches.length < 2) {
                initialPinchDistance = null;
            }
            if (e.touches.length === 0) {
                isPanningTouch = false;
            }
        });
        
        // --- LABEL SCALE CONTROLS (Kept as is) ---
        
        function redrawLabels(newSize) {
            currentLabelFontSize = newSize;

            if (currentImage && originalImageData) {
                // Restore original image data
                restoreState(originalImageData); 
                
                // Redraw all colored areas with new text size
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(canvas, 0, 0); 
                
                let currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                // NOTE: A full redraw of filled areas is not implemented here as it requires
                // tracking the coordinates and color of every filled region, which dramatically 
                // increases code complexity. For simplicity, this code only clears the map
                // and applies the new font size to FUTURE labels. 
                // A better approach would be to track all fill operations in a separate data structure.
            }
        }

        labelScaleSlider.addEventListener('input', (e) => {
            const newSize = parseInt(e.target.value);
            redrawLabels(newSize);
        });
        
        labelScaleResetBtn.addEventListener('click', () => {
            labelScaleSlider.value = DEFAULT_LABEL_FONT_SIZE;
            redrawLabels(DEFAULT_LABEL_FONT_SIZE);
        });
        
        // --- DOWNLOAD FUNCTIONALITY (Kept as is) ---
        downloadBtn.addEventListener('click', () => {
            if (!currentImage) {
                alert("No image loaded to download!");
                return;
            }

            const dataURL = canvas.toDataURL('image/png');
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = 'labeled_image.png';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });

        // Initial setup
        renderLabels();
        updateUtilityButtonState();
        populateColorSwatches();
        labelScaleSlider.value = DEFAULT_LABEL_FONT_SIZE; 
    </script>
</body>
</html>
